const express = require('express');
const { body, validationResult } = require('express-validator');
const { authenticateToken } = require('../middleware/auth');
const User = require('../models/User');
const Product = require('../models/Product');
const Sale = require('../models/Sale');
const logger = require('../utils/logger');
const rateLimit = require('express-rate-limit');

// Importar clientes de IA
const { OpenAI } = require('openai');
const Anthropic = require('@anthropic-ai/sdk');
const { GoogleGenerativeAI } = require('@google/generative-ai');

const router = express.Router();

// Rate limiting para IA
const aiLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minuto
  max: 30, // m√°ximo 30 requests por minuto
  message: {
    success: false,
    message: 'Muitas solicita√ß√µes para IA. Tente novamente em 1 minuto.',
    code: 'AI_RATE_LIMIT_EXCEEDED'
  }
});

// Configurar clientes de IA
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY
});

const googleAI = new GoogleGenerativeAI(process.env.GOOGLE_AI_API_KEY);

// Middleware de autentica√ß√£o
router.use(authenticateToken);

// Valida√ß√µes
const chatValidation = [
  body('message')
    .trim()
    .isLength({ min: 1, max: 2000 })
    .withMessage('Mensagem deve ter entre 1 e 2000 caracteres'),
  body('context')
    .optional()
    .isString()
    .withMessage('Contexto deve ser uma string'),
  body('aiType')
    .optional()
    .isIn(['tata', 'marketing', 'technical', 'stock'])
    .withMessage('Tipo de IA inv√°lido')
];

const analysisValidation = [
  body('type')
    .isIn(['product', 'sales', 'market', 'campaign'])
    .withMessage('Tipo de an√°lise inv√°lido'),
  body('data')
    .isObject()
    .withMessage('Dados s√£o obrigat√≥rios'),
  body('period')
    .optional()
    .isIn(['week', 'month', 'quarter', 'year'])
    .withMessage('Per√≠odo inv√°lido')
];

// Fun√ß√£o para escolher provedor de IA baseado na disponibilidade
const getAvailableAIProvider = async () => {
  const providers = [
    { name: 'openai', client: openai, available: !!process.env.OPENAI_API_KEY },
    { name: 'anthropic', client: anthropic, available: !!process.env.ANTHROPIC_API_KEY },
    { name: 'google', client: googleAI, available: !!process.env.GOOGLE_AI_API_KEY }
  ];
  
  // Retornar primeiro provedor dispon√≠vel
  return providers.find(provider => provider.available) || null;
};

// Fun√ß√£o para gerar resposta com fallback entre provedores
const generateAIResponse = async (prompt, context = '', aiType = 'tata') => {
  const providers = [
    { name: 'openai', client: openai, available: !!process.env.OPENAI_API_KEY },
    { name: 'anthropic', client: anthropic, available: !!process.env.ANTHROPIC_API_KEY },
    { name: 'google', client: googleAI, available: !!process.env.GOOGLE_AI_API_KEY }
  ];
  
  for (const provider of providers) {
    if (!provider.available) continue;
    
    try {
      let response;
      
      switch (provider.name) {
        case 'openai':
          const systemPrompt = getSystemPrompt(aiType);
          const completion = await openai.chat.completions.create({
            model: 'gpt-4-turbo-preview',
            messages: [
              { role: 'system', content: systemPrompt },
              { role: 'user', content: `${context}\n\n${prompt}` }
            ],
            max_tokens: 1000,
            temperature: 0.7
          });
          response = completion.choices[0].message.content;
          break;
          
        case 'anthropic':
          const anthropicPrompt = `${getSystemPrompt(aiType)}\n\nContexto: ${context}\n\nUsu√°rio: ${prompt}\n\nAssistente:`;
          const anthropicResponse = await anthropic.completions.create({
            model: 'claude-3-sonnet-20240229',
            prompt: anthropicPrompt,
            max_tokens: 1000,
            temperature: 0.7
          });
          response = anthropicResponse.completion;
          break;
          
        case 'google':
          const model = googleAI.getGenerativeModel({ model: 'gemini-pro' });
          const googlePrompt = `${getSystemPrompt(aiType)}\n\nContexto: ${context}\n\nUsu√°rio: ${prompt}`;
          const result = await model.generateContent(googlePrompt);
          response = result.response.text();
          break;
      }
      
      return {
        success: true,
        response,
        provider: provider.name
      };
      
    } catch (error) {
      logger.error(`Erro no provedor ${provider.name}:`, error);
      continue; // Tentar pr√≥ximo provedor
    }
  }
  
  // Se todos os provedores falharam
  throw new Error('Todos os provedores de IA est√£o indispon√≠veis');
};

// Fun√ß√£o para obter prompt do sistema baseado no tipo de IA
const getSystemPrompt = (aiType) => {
  const basePrompt = `Voc√™ √© uma assistente de IA especializada em e-commerce e marketplace, trabalhando para a Place IA. 
Sempre responda em portugu√™s brasileiro de forma amig√°vel e profissional.`;
  
  switch (aiType) {
    case 'tata':
      return `${basePrompt}

Voc√™ √© a TaTa, uma assistente virtual amig√°vel e carism√°tica da Place IA. 
Sua personalidade √©:
- Amig√°vel e acolhedora
- Proativa em ajudar
- Conhecedora de e-commerce e marketplaces
- Sempre positiva e motivadora
- Usa emojis ocasionalmente para ser mais expressiva

Voc√™ ajuda os usu√°rios com:
- An√°lise de vendas e produtos
- Sugest√µes de melhorias
- D√∫vidas sobre a plataforma
- Estrat√©gias de marketing
- Gest√£o de estoque

Sempre termine suas respostas perguntando se pode ajudar com mais alguma coisa.`;
      
    case 'marketing':
      return `${basePrompt}

Voc√™ √© especialista em marketing digital e publicidade para e-commerce.
Foque em:
- Estrat√©gias de an√∫ncios (Google Ads, Meta, TikTok)
- Otimiza√ß√£o de campanhas
- An√°lise de ROI e ROAS
- Segmenta√ß√£o de p√∫blico
- Copy e criativos
- Tend√™ncias de mercado`;
      
    case 'technical':
      return `${basePrompt}

Voc√™ √© especialista t√©cnico em integra√ß√µes e automa√ß√µes.
Foque em:
- Diagn√≥stico de problemas t√©cnicos
- Integra√ß√µes com marketplaces
- APIs e webhooks
- Automa√ß√µes de processos
- Sincroniza√ß√£o de dados
- Troubleshooting`;
      
    case 'stock':
      return `${basePrompt}

Voc√™ √© especialista em gest√£o de estoque e log√≠stica.
Foque em:
- Controle de estoque
- Previs√£o de demanda
- Reposi√ß√£o autom√°tica
- An√°lise de giro de produtos
- Otimiza√ß√£o de armazenagem
- Gest√£o de fornecedores`;
      
    default:
      return basePrompt;
  }
};

// Fun√ß√£o para obter contexto do usu√°rio
const getUserContext = async (userId) => {
  try {
    const [user, recentSales, topProducts, lowStockProducts] = await Promise.all([
      User.findById(userId).select('name company subscription marketplace'),
      Sale.find({ owner: userId })
        .sort({ createdAt: -1 })
        .limit(5)
        .populate('items.productId', 'name sku'),
      Product.find({ owner: userId })
        .sort({ 'metrics.totalSold': -1 })
        .limit(5)
        .select('name sku metrics'),
      Product.find({
        owner: userId,
        $expr: { $lte: ['$stock.quantity', '$stock.minQuantity'] }
      })
        .limit(5)
        .select('name sku stock')
    ]);
    
    return {
      user: {
        name: user.name,
        company: user.company?.name || 'Empresa',
        plan: user.subscription?.plan || 'B√°sico',
        marketplaces: user.marketplace?.connectedPlatforms || []
      },
      recentSales: recentSales.length,
      topProducts: topProducts.map(p => ({ name: p.name, sku: p.sku, sold: p.metrics.totalSold })),
      lowStockProducts: lowStockProducts.map(p => ({ name: p.name, sku: p.sku, stock: p.stock.quantity }))
    };
  } catch (error) {
    logger.error('Erro ao obter contexto do usu√°rio:', error);
    return {};
  }
};

// ROTA: Chat com TaTa IA
router.post('/chat', aiLimiter, chatValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Dados inv√°lidos',
        errors: errors.array()
      });
    }
    
    const { message, context = '', aiType = 'tata' } = req.body;
    const userId = req.user.id;
    
    // Obter contexto do usu√°rio
    const userContext = await getUserContext(userId);
    const fullContext = `${context}\n\nContexto do usu√°rio: ${JSON.stringify(userContext, null, 2)}`;
    
    // Gerar resposta da IA
    const aiResponse = await generateAIResponse(message, fullContext, aiType);
    
    // Log da intera√ß√£o
    logger.info('Intera√ß√£o com IA', {
      userId,
      aiType,
      provider: aiResponse.provider,
      messageLength: message.length
    });
    
    res.json({
      success: true,
      data: {
        message: aiResponse.response,
        aiType,
        provider: aiResponse.provider,
        timestamp: new Date()
      }
    });
    
  } catch (error) {
    logger.error('Erro no chat com IA:', error);
    
    // Resposta de fallback
    const fallbackResponses = {
      tata: 'Oi! üòä Desculpe, estou com um probleminha t√©cnico no momento. Mas n√£o se preocupe, nossa equipe j√° est√° cuidando disso! Enquanto isso, voc√™ pode verificar seu dashboard ou entrar em contato com nosso suporte. Posso ajudar com mais alguma coisa?',
      marketing: 'Desculpe, estou temporariamente indispon√≠vel. Para estrat√©gias de marketing, recomendo verificar suas campanhas ativas no painel ou consultar nossos relat√≥rios de performance.',
      technical: 'Sistema temporariamente indispon√≠vel. Para quest√µes t√©cnicas urgentes, consulte nossa documenta√ß√£o ou entre em contato com o suporte t√©cnico.',
      stock: 'Servi√ßo temporariamente indispon√≠vel. Para gest√£o de estoque, acesse o relat√≥rio de produtos no seu dashboard.'
    };
    
    res.json({
      success: true,
      data: {
        message: fallbackResponses[req.body.aiType] || fallbackResponses.tata,
        aiType: req.body.aiType || 'tata',
        provider: 'fallback',
        timestamp: new Date()
      }
    });
  }
});

// ROTA: An√°lise inteligente
router.post('/analyze', aiLimiter, analysisValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Dados inv√°lidos',
        errors: errors.array()
      });
    }
    
    const { type, data, period = 'month' } = req.body;
    const userId = req.user.id;
    
    let analysisPrompt = '';
    let context = '';
    
    switch (type) {
      case 'product':
        analysisPrompt = `Analise este produto e forne√ßa insights sobre performance, otimiza√ß√µes e estrat√©gias de venda:`;
        context = `Dados do produto: ${JSON.stringify(data, null, 2)}`;
        break;
        
      case 'sales':
        analysisPrompt = `Analise estes dados de vendas e forne√ßa insights sobre tend√™ncias, oportunidades e recomenda√ß√µes:`;
        context = `Dados de vendas (${period}): ${JSON.stringify(data, null, 2)}`;
        break;
        
      case 'market':
        analysisPrompt = `Analise este mercado/categoria e forne√ßa insights sobre concorr√™ncia, pre√ßos e oportunidades:`;
        context = `Dados de mercado: ${JSON.stringify(data, null, 2)}`;
        break;
        
      case 'campaign':
        analysisPrompt = `Analise esta campanha publicit√°ria e forne√ßa insights sobre performance e otimiza√ß√µes:`;
        context = `Dados da campanha: ${JSON.stringify(data, null, 2)}`;
        break;
    }
    
    // Gerar an√°lise
    const aiResponse = await generateAIResponse(analysisPrompt, context, 'marketing');
    
    // Log da an√°lise
    logger.info('An√°lise IA realizada', {
      userId,
      type,
      period,
      provider: aiResponse.provider
    });
    
    res.json({
      success: true,
      data: {
        analysis: aiResponse.response,
        type,
        period,
        provider: aiResponse.provider,
        timestamp: new Date()
      }
    });
    
  } catch (error) {
    logger.error('Erro na an√°lise IA:', error);
    res.status(500).json({
      success: false,
      message: 'Erro ao gerar an√°lise'
    });
  }
});

// ROTA: Sugest√µes autom√°ticas
router.get('/suggestions', async (req, res) => {
  try {
    const { type = 'general' } = req.query;
    const userId = req.user.id;
    
    // Obter dados do usu√°rio para sugest√µes
    const userContext = await getUserContext(userId);
    
    let suggestionsPrompt = '';
    
    switch (type) {
      case 'marketing':
        suggestionsPrompt = 'Baseado nos dados do usu√°rio, sugira 3 estrat√©gias de marketing espec√≠ficas e acion√°veis:';
        break;
      case 'products':
        suggestionsPrompt = 'Baseado nos produtos e vendas, sugira 3 otimiza√ß√µes para melhorar a performance:';
        break;
      case 'stock':
        suggestionsPrompt = 'Baseado no estoque atual, sugira 3 a√ß√µes para otimizar a gest√£o:';
        break;
      default:
        suggestionsPrompt = 'Baseado no perfil do usu√°rio, sugira 3 a√ß√µes priorit√°rias para melhorar os resultados:';
    }
    
    const context = `Dados do usu√°rio: ${JSON.stringify(userContext, null, 2)}`;
    
    // Gerar sugest√µes
    const aiResponse = await generateAIResponse(suggestionsPrompt, context, 'tata');
    
    res.json({
      success: true,
      data: {
        suggestions: aiResponse.response,
        type,
        provider: aiResponse.provider,
        timestamp: new Date()
      }
    });
    
  } catch (error) {
    logger.error('Erro ao gerar sugest√µes:', error);
    
    // Sugest√µes de fallback
    const fallbackSuggestions = {
      general: [
        'üìä Analise seus produtos mais vendidos e invista em estoque',
        'üéØ Configure campanhas de remarketing para aumentar convers√µes',
        'üì± Otimize suas descri√ß√µes de produtos com palavras-chave relevantes'
      ],
      marketing: [
        'üéØ Teste diferentes p√∫blicos-alvo em suas campanhas',
        'üì∏ Invista em imagens de alta qualidade para seus produtos',
        'üí∞ Ajuste seus lances baseado no ROI de cada campanha'
      ],
      products: [
        'üè∑Ô∏è Revise os pre√ßos dos produtos com baixa convers√£o',
        'üìù Melhore as descri√ß√µes dos produtos mais visualizados',
        '‚≠ê Incentive avalia√ß√µes dos clientes satisfeitos'
      ],
      stock: [
        'üì¶ Configure alertas para produtos com estoque baixo',
        'üìà Analise a sazonalidade para planejar reposi√ß√µes',
        'üîÑ Automatize pedidos para fornecedores confi√°veis'
      ]
    };
    
    res.json({
      success: true,
      data: {
        suggestions: fallbackSuggestions[req.query.type] || fallbackSuggestions.general,
        type: req.query.type || 'general',
        provider: 'fallback',
        timestamp: new Date()
      }
    });
  }
});

// ROTA: Hist√≥rico de conversas
router.get('/chat/history', async (req, res) => {
  try {
    const { page = 1, limit = 20, aiType } = req.query;
    const userId = req.user.id;
    
    // Aqui voc√™ implementaria um sistema de hist√≥rico de conversas
    // Por enquanto, retornar dados mockados
    const history = {
      docs: [
        {
          id: '1',
          message: 'Como est√£o minhas vendas este m√™s?',
          response: 'Suas vendas est√£o √≥timas! üìà Voc√™ vendeu 45 produtos este m√™s...',
          aiType: 'tata',
          timestamp: new Date()
        },
        {
          id: '2',
          message: 'Quais produtos est√£o com estoque baixo?',
          response: 'Identifiquei 3 produtos com estoque baixo que precisam de aten√ß√£o...',
          aiType: 'stock',
          timestamp: new Date(Date.now() - 3600000)
        }
      ],
      totalDocs: 2,
      page: 1,
      totalPages: 1,
      hasNextPage: false,
      hasPrevPage: false
    };
    
    res.json({
      success: true,
      data: {
        history: history.docs,
        pagination: {
          currentPage: history.page,
          totalPages: history.totalPages,
          totalDocs: history.totalDocs,
          hasNextPage: history.hasNextPage,
          hasPrevPage: history.hasPrevPage
        }
      }
    });
    
  } catch (error) {
    logger.error('Erro ao buscar hist√≥rico:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// ROTA: Status dos provedores de IA
router.get('/status', async (req, res) => {
  try {
    const providers = [
      {
        name: 'OpenAI',
        key: 'openai',
        available: !!process.env.OPENAI_API_KEY,
        status: 'active'
      },
      {
        name: 'Anthropic',
        key: 'anthropic',
        available: !!process.env.ANTHROPIC_API_KEY,
        status: 'active'
      },
      {
        name: 'Google AI',
        key: 'google',
        available: !!process.env.GOOGLE_AI_API_KEY,
        status: 'active'
      }
    ];
    
    const activeProviders = providers.filter(p => p.available);
    
    res.json({
      success: true,
      data: {
        providers,
        activeCount: activeProviders.length,
        totalCount: providers.length,
        primaryProvider: activeProviders[0]?.key || null
      }
    });
    
  } catch (error) {
    logger.error('Erro ao verificar status dos provedores:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

module.exports = router;